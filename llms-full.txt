# Java Client Template

> A structured template for building scalable web clients using Spring Boot, designed for seamless integration with Cyoda over gRPC and REST. Features workflow-driven backend interactions with fluent serialization APIs for type-safe processing.

## üöÄ **CRITICAL: EntityService Performance-Optimized API**

The EntityService has been completely redesigned with **clear performance guidance** to eliminate AI confusion:

### **Method Selection Guide (CRITICAL)**
```java
EntityResponse<MyEntity> myEntity = entityService.getById(technicalId, MyEntity.class);
EntityResponse<MyEntity> myEntity = entityService.findByBusinessId(MyEntity.class, "CART-123", "myEntityId");
List<EntityResponse<MyOtherEntity>> myOtherEntitys = entityService.findAll(MyOtherEntity.class);
List<EntityResponse<MyOtherEntity>> results = entityService.search(MyOtherEntity.class, condition);
```

### **EntityResponse Structure (CRITICAL)**
```java
EntityResponse<MyEntity> response = entityService.getById(myEntityId, MyEntity.class);

// Access entity (Lombok @Data generates getEntity() automatically)
MyEntity myEntity = response.getEntity();

// Access metadata (includes technical UUID and workflow state)
UUID technicalId = response.getMetadata().getId();      // Store for future operations
String workflowState = response.getMetadata().getState(); // Current workflow state
```

### **üö´ FORBIDDEN PATTERNS - NEVER USE THESE**
```java
// ‚ùå FORBIDDEN Processor patterns
public ProcessorName(SerializerFactory factory, ObjectMapper objectMapper) { ... } // Never inject ObjectMapper
Map<String, Object> payloadMap = objectMapper.convertValue(request.getPayload().getData(), Map.class); // Never extract manually

// ‚ùå FORBIDDEN Controller patterns
@PostMapping
public ResponseEntity<Object> create(@RequestBody Map<String, Object> request) { ... } // Never use Map<String, Object>

// ‚ùå FORBIDDEN EntityService patterns
entityService.getItem(uuid, Class); // Use getById() instead
entityService.findByCondition(...); // Use search() instead
entityService.findByField(...); // Use search() instead
```

## Documentation

default branch: main
- [README](https://github.com/Cyoda-platform/java-client-template/${branch}/README.md): Complete project documentation including setup, architecture, and workflow configuration
- [Usage Rules](https://github.com/Cyoda-platform/java-client-template/${branch}/usage-rules.md): Developer and AI agent guidelines for following project conventions

## Requirements & Specifications

- [Functional Requirements](https://github.com/Cyoda-platform/java-client-template/${branch}/src/main/java/com/java_template/prototype/functional_requirement.md): Detailed functional requirements for the user application
- [User Requirements](https://github.com/Cyoda-platform/java-client-template/${branch}/src/main/java/com/java_template/prototype/user_requirement.md): User-focused requirements specification for the user application

## Configuration

- [Build Configuration](https://github.com/Cyoda-platform/java-client-template/${branch}/build.gradle): Gradle build configuration with dependencies and plugins
- [Environment Template](https://github.com/Cyoda-platform/java-client-template/${branch}/.env.template): Environment variables template for Cyoda integration

---

# README.md

# Java Client Template

A structured template for building scalable web clients using **Spring Boot**, designed for seamless integration with **Cyoda** over **gRPC** and **REST**.

---

## üöÄ Features

- **Spring Boot**-based fast backend starter.
- Modular, extensible structure for rapid iteration.
- Built-in support for **gRPC** and **REST** APIs.
- Integration with **Cyoda**: workflow-driven backend interactions.
- Serialization architecture with fluent APIs for type-safe processing.

---

## üõ†Ô∏è Getting Started

> ‚òï **Java 21 Required**
> Make sure Java 21 is installed and set as the active version.

### 1. Clone the Project

```bash
git clone <your-repository-URL>
cd java-client-template
```

### 2. üß∞ Run Workflow Import Tool

#### Option 1: Run via Gradle (recommended for local development)
```bash
./gradlew runApp -PmainClass=com.java_template.common.tool.WorkflowImportTool
```

#### Option 2: Build and Run JAR (recommended for CI or scripting)
```bash
./gradlew bootJarWorkflowImport
java -jar build/libs/java-client-template-1.0-SNAPSHOT-workflow-import.jar
```

### 3. ‚ñ∂Ô∏è Run the Application

#### Option 1: Run via Gradle
```bash
./gradlew runApp
```

#### Option 2: Run Manually After Build
```bash
./gradlew build
java -jar build/libs/java-client-template-1.0-SNAPSHOT.jar
```

> Access the app: [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html)
>
> **Note**: The default port is 8080 as configured in `src/main/resources/application.yml`. You can change this by setting the `server.port` property.

---

## üß© Project Structure

### `common/`
Integration logic with Cyoda.

- `auth/` ‚Äì Manages login and refresh token logic (modifications not typically required).
- `config/` ‚Äì Contains constants, environment variables from .env, and enums.
- `grpc/` ‚Äì Handles integration with the Cyoda gRPC server (modifications usually unnecessary).
- `repository/` ‚Äì Facilitates integration with the Cyoda REST API (modifications usually unnecessary).
- `service/` ‚Äì Service layer for your application.
- `util/` ‚Äì Various utility functions.
- `workflow/` ‚Äì Core workflow processing architecture with CyodaProcessor and CyodaCriterion interfaces.
- `serializer/` ‚Äì Serialization layer with fluent APIs for processing requests and responses.
- `tool/` ‚Äì Utility tools like WorkflowImportTool for importing workflow configurations.

To interact with **Cyoda**, use `common/service/EntityService.java`, which provides all necessary methods.

To add new integrations with Cyoda, extend the following files:

- **Interface** ‚Äî `common/service/EntityService.java`: defines service methods; abstraction layer for Cyoda. Optional to modify.
- **Implementation** ‚Äî `common/service/EntityServiceImpl.java`: implements interface methods and business logic. Optional to modify.
- **Repository Interface** ‚Äî `common/repository/CrudRepository.java`: defines a generic interface. Modify only if additional operations are needed.
- **Cyoda Repository** ‚Äî `common/repository/CyodaRepository.java`: implements repository methods. Modify only if needed.

> ‚ö†Ô∏è `CrudRepository.java` and `CyodaRepository.java` rarely change ‚Äî only for significant updates to the data access layer.

‚úÖ Always interact with the **service interface**, not directly with the repository.

---

### `application/`
Application-specific logic and components:

- `controller/` ‚Äì HTTP endpoints and REST API controllers.
- `entity/` ‚Äì Domain entities (e.g., `pet/Pet.java`) that implement `CyodaEntity`.
- `processor/` ‚Äì Workflow processors that implement `CyodaProcessor` interface.
- `criterion/` ‚Äì Workflow criteria that implement `CyodaCriterion` interface.

### `entity/`
Domain logic structure. Contains entity structures.

- `$entity_name/Workflow.json` ‚Äì Workflow configuration files should be placed alongside entities in `application/entity/`.

---

## ‚öôÔ∏è EntityService API - Performance-Optimized & Simplified

The EntityService has been completely redesigned with **clear performance guidance** and **simplified method signatures** to eliminate AI confusion and improve developer experience.

### üöÄ **Primary Methods (Use These)**

| Method | Performance | Use Case | Example |
|--------|-------------|----------|---------|
| `getById(UUID id, Class<T> clazz)` | **FASTEST** | When you have technical UUID | `entityService.getById(uuid, MyEntity.class)` |
| `findByBusinessId(Class<T> clazz, String businessId, String fieldName)` | **MEDIUM** | User-facing identifiers | `entityService.findByBusinessId(MyEntity.class, "CART-123", "myEntityId")` |
| `findAll(Class<T> clazz)` | **SLOW** | Get all entities (use sparingly) | `entityService.findAll(MyOtherEntity.class)` |
| `search(Class<T> clazz, SearchConditionRequest condition)` | **SLOWEST** | Complex queries | `entityService.search(MyOtherEntity.class, condition)` |

### üíæ **Mutation Methods**

| Method | Description | Example |
|--------|-------------|---------|
| `save(T entity)` | Create new entity | `entityService.save(newMyEntity)` |
| `update(UUID id, T entity, String transition)` | Update by technical ID | `entityService.update(uuid, myEntity, "CHECKOUT")` |
| `updateByBusinessId(T entity, String fieldName, String transition)` | Update by business ID | `entityService.updateByBusinessId(myEntity, "myEntityId", null)` |
| `deleteById(UUID id)` | Delete by technical ID | `entityService.deleteById(uuid)` |
| `deleteByBusinessId(Class<T> clazz, String businessId, String fieldName)` | Delete by business ID | `entityService.deleteByBusinessId(MyEntity.class, "CART-123", "myEntityId")` |

### üîç Query Operations (Type-Safe)

| Method                                                                                  | Return type                     | Description                           |
|-----------------------------------------------------------------------------------------|---------------------------------|---------------------------------------|
| `getItem(UUID id, Class<T> entityClass)`                                               | `EntityResponse<T>`             | Get by technical ID                   |
| `getItems(Class<T> entityClass, Integer pageSize, Integer pageNumber, Date pointTime)` | `List<EntityResponse<T>>`       | Get all with pagination               |
| `getItemsByCondition(Class<T> entityClass, SearchConditionRequest condition, boolean inMemory)` | `List<EntityResponse<T>>` | Advanced search with conditions |
| `getFirstItemByCondition(Class<T> entityClass, SearchConditionRequest condition, boolean inMemory)` | `Optional<EntityResponse<T>>` | Get first match |

### üè™ Business ID Operations (Convenience)

| Method                                                                                  | Return type                     | Description                           |
|-----------------------------------------------------------------------------------------|---------------------------------|---------------------------------------|
| `findByBusinessId(Class<T> entityClass, String businessId)`                            | `EntityResponse<T>`             | Find by business ID (SKU, orderId, etc.) |
| `findAll(Class<T> entityClass)`                                                         | `List<EntityResponse<T>>`       | Find all entities                     |
| `findByField(Class<T> entityClass, String fieldName, String value)`                    | `List<EntityResponse<T>>`       | Find by field value (convenience)     |
| `findByCondition(Class<T> entityClass, SearchConditionRequest condition, boolean inMemory)` | `List<EntityResponse<T>>` | Advanced search (convenience) |
| `updateByBusinessId(T entity, String transition)`                                       | `EntityResponse<T>`             | Update by business ID                 |
| `deleteByBusinessId(Class<T> entityClass, String businessId)`                          | `boolean`                       | Delete by business ID                 |

### ‚ú® Key Improvements

- **üîÑ JPA-Style Naming**: `save()`, `findAll()`, `deleteById()` - familiar to Spring Boot developers
- **üõ°Ô∏è Type Safety**: All methods use proper generics with `<T extends CyodaEntity>`
- **üìä Rich Metadata**: Every response includes `EntityResponse<T>` with technical ID, timestamps, etc.
- **‚ö° Synchronous**: No more `CompletableFuture` - clean, simple method calls
- **üéØ Transition Support**: Update operations support optional workflow transitions
- **üß† Consistent API**: `List<EntityResponse<T>>` everywhere for multiple entities

### üîë EntityResponse<T> - Rich Metadata Support

All EntityService methods return `EntityResponse<T>` which contains both the entity and metadata:

```java
EntityResponse<MyEntity> response = entityService.getById(myEntityId, MyEntity.class);

// Access the entity (Lombok @Data generates getEntity() automatically)
MyEntity myEntity = response.getEntity();

// Access metadata (includes technical UUID and workflow state)
UUID technicalId = response.getMetadata().getId();      // Use for subsequent operations
String workflowState = response.getMetadata().getState(); // Current workflow state
LocalDateTime created = response.getMetadata().getCreatedAt();
LocalDateTime updated = response.getMetadata().getUpdatedAt();
```

**JSON Structure:**
```json
{
  "entity": {
    "myEntityId": "CART-123",
    "items": [...],
    "total": 99.99
  },
  "metadata": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "state": "ACTIVE"
  }
}
```

### üîÑ **Unified Processor Interface**

Processors can now use the unified `.toEntityResponse()` method for consistency with controllers:

```java
// Traditional entity processing
return serializer.withRequest(request)
    .toEntityWithMetadata(EntityName.class)
    .validate(this::isValidEntity, "Invalid entity")
    .map(this::processEntityLogic)
    .complete();

// NEW: Unified EntityResponse processing (recommended)
return serializer.withRequest(request)
    .toEntityResponse(EntityName.class)  // Unified with controllers
    .validate(this::isValidEntityResponse, "Invalid entity response")
    .map(this::processEntityResponseLogic)
    .complete();

private EntityResponse<EntityName> processEntityResponseLogic(ProcessorEntityResponseExecutionContext<EntityName> context) {
    EntityResponse<EntityName> entityResponse = context.entityResponse();
    EntityName entity = entityResponse.getEntity();

    // Direct access to metadata (same as controllers)
    UUID currentEntityId = entityResponse.getMetadata().getId();
    String currentState = entityResponse.getMetadata().getState();

    // Process business logic
    return entityResponse; // Cannot modify current entity state
}
```

### üì¶ Usage Examples

#### Performance-Optimized Operations
```java
EntityResponse<MyOtherEntity> response = entityService.getById(technicalId, MyOtherEntity.class);
MyOtherEntity myOtherEntity = response.getEntity();

EntityResponse<MyOtherEntity> myOtherEntityResponse = entityService.findByBusinessId(MyOtherEntity.class, "SKU123", "sku");
MyOtherEntity myOtherEntity = myOtherEntityResponse.getEntity();

List<EntityResponse<MyOtherEntity>> responses = entityService.findAll(MyOtherEntity.class);
List<MyOtherEntity> myOtherEntitys = responses.stream().map(EntityResponse::getEntity).toList();

// Update with transition
EntityResponse<MyOtherEntity> updated = entityService.updateByBusinessId(myOtherEntity, "sku", "approve");

// Delete by business ID
boolean deleted = entityService.deleteByBusinessId(MyOtherEntity.class, "SKU123", "sku");
```

#### Advanced Search with Type-Safe Conditions
```java
SearchConditionRequest condition = SearchConditionRequest.group("AND",
    Condition.of("$.category", "EQUALS", "electronics"),
    Condition.of("$.price", "GREATER_THAN", 100),
    Condition.of("$.inStock", "EQUALS", true)
);

List<EntityResponse<MyOtherEntity>> results = entityService.search(MyOtherEntity.class, condition);
List<MyOtherEntity> myOtherEntitys = results.stream().map(EntityResponse::getEntity).toList();
```



#### Working with Technical IDs
```java
// Get entity by technical ID
EntityResponse<MyOtherEntity> response = entityService.getItem(technicalId, MyOtherEntity.class);

// Update using technical ID with transition
EntityResponse<MyOtherEntity> updated = entityService.update(technicalId, myOtherEntity, "transition_name");

// Delete by technical ID
UUID deletedId = entityService.deleteById(technicalId);
```

---

## üîÑ Workflow Configuration

Located at:
```
application/entity/$entity_name/Workflow.json
```

> **Note**: Workflow configuration files should be placed alongside their corresponding entity classes in the `application/entity/` directory structure.

This file defines the workflow configuration using a **finite-state machine (FSM)**
model, which specifies states and transitions between them.

The workflow JSON consists of:
- **Metadata**: `version`, `name`, `desc`, `initialState`, `active`
- **Global criterion**: Optional workflow-level criterion for applicability
- **States**: Dictionary of states with their transitions
- **Transitions**: Each transition has `name`, `next`, `manual` flag, and optional `processors`/`criterion`

**Rules:**
- Start from the defined `initialState`.
- Avoid loops.
- If there are **multiple transitions** from one state,
  a **criterion** is required for each transition to decide which one to use.

FSM example:

```json
{
  "version": "1.0",
  "name": "template_workflow",
  "desc": "Template FSM with structured states, transitions, processors, and criterions",
  "initialState": "none",
  "active": true,
  "states": {
    "none": {
      "transitions": [
        {
          "name": "transition_to_01",
          "next": "state_01"
        }
      ]
    },
    "state_01": {
      "transitions": [
        {
          "name": "transition_to_02",
          "next": "state_02",
          "manual": true,
          "processors": [
            {
              "name": "example_function_name",
              "executionMode": "ASYNC_NEW_TX",
              "config": {
                "attachEntity": true,
                "calculationNodesTags": "cyoda_application",
                "responseTimeoutMs": 3000,
                "retryPolicy": "FIXED"
              }
            }
          ]
        }
      ]
    },
    "state_02": {
      "transitions": [
        {
          "name": "transition_with_criterion_simple",
          "next": "state_criterion_check_01",
          "processors": [
            {
              "name": "example_function_name",
              "executionMode": "ASYNC_NEW_TX",
              "config": {
                "attachEntity": true,
                "calculationNodesTags": "cyoda_application",
                "responseTimeoutMs": 3000,
                "retryPolicy": "FIXED"
              }
            }
          ],
          "criterion": {
            "type": "function",
            "function": {
              "name": "example_function_name_returns_bool",
              "config": {
                "attachEntity": true,
                "calculationNodesTags": "cyoda_application",
                "responseTimeoutMs": 5000,
                "retryPolicy": "FIXED"
              }
            }
          }
        }
      ]
    },
    "state_criterion_check_01": {
      "transitions": [
        {
          "name": "transition_with_criterion_group",
          "next": "state_terminal",
          "criterion": {
            "type": "group",
            "operator": "AND",
            "conditions": [
              {
                "type": "simple",
                "jsonPath": "$.sampleFieldA",
                "operation": "EQUALS",
                "value": "template_value_01"
              }
            ]
          }
        }
      ]
    },
    "state_terminal": {
      "transitions": []
    }
  }
}
```

### ‚úÖ Criterion Types

There are **three types of criteria** used to control transitions:

1. **Simple criterion** ‚Äî Direct field comparison
   Evaluates a single field against a value using an operation.

   ```json
   "criterion": {
     "type": "simple",
     "jsonPath": "$.customerType",
     "operation": "EQUALS",
     "value": "premium"
   }
   ```

2. **Group criterion** ‚Äî Logical combination of conditions
   Combines multiple simple or group conditions using logical operators.

   > ‚úÖ **Note:** `Group` criteria support **nesting**.
   > You can include both `simple` and `group` conditions inside the `conditions` array.

   ```json
   "criterion": {
     "type": "group",
     "operator": "AND",
     "conditions": [
       {
         "type": "simple",
         "jsonPath": "$.creditScore",
         "operation": "GREATER_OR_EQUAL",
         "value": 700
       },
       {
         "type": "simple",
         "jsonPath": "$.annualRevenue",
         "operation": "GREATER_THAN",
         "value": 1000000
       }
     ]
   }
   ```

3. **Function criterion** ‚Äî Custom client-side evaluation
   Executes a custom function with optional nested criterion.

   > ‚ö†Ô∏è The function must be implemented as a `CyodaCriterion` component.
   > Its name **must be unique and match** `function.name`.

   ```json
   "criterion": {
     "type": "function",
     "function": {
       "name": "example_function_name_returns_bool",
       "config": {
         "attachEntity": true,
         "calculationNodesTags": "validation,criteria",
         "responseTimeoutMs": 5000,
         "retryPolicy": "FIXED"
       },
       "criterion": {
         "type": "simple",
         "jsonPath": "$.sampleFieldB",
         "operation": "GREATER_THAN",
         "value": 100
       }
     }
   }
   ```

   > **jsonPath field reference:**
   > - Use the **`$.` prefix** for custom (business) fields of the entity.
   > - Use **no prefix** for built-in entity meta-fields.
   >   Supported meta-fields: `state`, `previousTransition`, `creationDate`, `lastUpdateTime`.

Supported criterion `types`:

- `simple`
- `group`
- `function`

Supported group `operator` values:

- `AND`
- `OR`
- `NOT`

Supported operation values (`*_OR_EQUAL` includes the boundary):

```
EQUALS, NOT_EQUAL, IS_NULL, NOT_NULL, GREATER_THAN, GREATER_OR_EQUAL, LESS_THAN, LESS_OR_EQUAL,
CONTAINS, STARTS_WITH, ENDS_WITH, NOT_CONTAINS, NOT_STARTS_WITH, NOT_ENDS_WITH, MATCHES_PATTERN, BETWEEN, BETWEEN_INCLUSIVE
```

---

## üß† Workflow Processors

The logic for processing workflows is implemented using **CyodaProcessor** and **CyodaCriterion** interfaces in the `application/` directory.

### Processor Architecture

Processors implement the `CyodaProcessor` interface and use the **EntityProcessingChain** API for type-safe entity processing. Processors are configured in workflow transitions with execution modes and configuration options:

```java
@Component
public class AddLastModifiedTimestamp implements CyodaProcessor {

    private final ProcessorSerializer serializer;

    @Override
    public EntityProcessorCalculationResponse process(CyodaEventContext<EntityProcessorCalculationRequest> context) {
        EntityProcessorCalculationRequest request = context.getEvent();

        // Fluent entity processing with validation
        return serializer.withRequest(request)
            .toEntityWithMetadata(Pet.class)
            .validate(pet -> pet.getId() != null && pet.getName() != null)
            .map(pet -> {
                pet.addLastModifiedTimestamp();
                return pet;
            })
            .complete();
    }

    @Override
    public boolean supports(OperationSpecification opSpec) {
        // Entity-based processing: check operation name AND model compatibility
        return "example_function_name".equals(opSpec.operationName()) &&
               "Pet".equals(opSpec.modelKey().getName()) &&
               opSpec.modelKey().getVersion() >= 1;
    }
}
```

### Processor Configuration

Processors in workflow transitions support various execution modes and configuration options:

```json
"processors": [
  {
    "name": "example_function_name",
    "executionMode": "SYNC",
    "config": {
      "attachEntity": true,
      "calculationNodesTags": "test_tag_01",
      "responseTimeoutMs": 3000,
      "retryPolicy": "FIXED"
    }
  }
]
```

**Execution Modes:**
- `SYNC` - Synchronous execution (default)
- `ASYNC_SAME_TX` - Asynchronous execution in the same transaction
- `ASYNC_NEW_TX` - Asynchronous execution in new transaction

**Configuration Options:**
- `attachEntity` - Whether to attach entity data to the request
- `calculationNodesTags` - Tags for calculation node selection
- `responseTimeoutMs` - Response timeout in milliseconds
- `retryPolicy` - Retry policy for failed executions

### Execution Mode Reference

```json
"executionMode": {
  "type": "string",
  "description": "Execution mode of the processor",
  "enum": [
    "SYNC",
    "ASYNC_SAME_TX",
    "ASYNC_NEW_TX"
  ],
  "default": "SYNC"
}
```

### EntityProcessingChain API

The **EntityProcessingChain** provides a clean, type-safe API for entity processing:

- `toEntityWithMetadata(Class<T>)` - Extract entity and initiate entity flow
- `map(Function<T, T>)` - Transform entity instances
- `validate(Function<T, Boolean>)` - Validate entities with default error message
- `validate(Function<T, Boolean>, String)` - Validate entities with custom error message
- `toJsonFlow(Function<T, JsonNode>)` - Switch to JSON processing
- `complete()` - Complete processing with automatic entity-to-JSON conversion
- `complete(Function<T, JsonNode>)` - Complete with custom entity converter

### Criteria Implementation

Criteria implement the `CyodaCriterion` interface for condition checking using **EvaluationOutcome** sealed classes with **logical chaining**:

```java
@Component
public class IsValidPet implements CyodaCriterion {

    private final CriterionSerializer serializer;

    @Override
    public EntityCriteriaCalculationResponse check(CyodaEventContext<EntityCriteriaCalculationRequest> context) {
        EntityCriteriaCalculationRequest request = context.getEvent();

        return serializer.withRequest(request)
            .evaluateEntity(Pet.class, this::validatePet)
            .withReasonAttachment(ReasonAttachmentStrategy.toWarnings())
            .complete();
    }

    private EvaluationOutcome validatePet(CriterionSerializer.CriterionEntityEvaluationContext<Pet> context) {
        Pet pet = context.entityWithMetadata().entity();
        // Access metadata if needed: UUID id = context.entityWithMetadata().getId();

        // Chain all validation checks with AND logic - first failure stops the chain
        return validatePetExists(pet)
            .and(validatePetBasicValidity(pet))
            .and(validateBasicStructure(pet))
            .and(validateBusinessRules(pet))
            .and(validateDataQuality(pet));
    }

    private EvaluationOutcome validatePetExists(Pet pet) {
        return pet == null ?
            EvaluationOutcome.Fail.structuralFailure("Pet entity is null") :
            EvaluationOutcome.success();
    }

    private EvaluationOutcome validateBasicStructure(Pet pet) {
        // Chain multiple field validations
        return validatePetId(pet).and(validatePetName(pet));
    }

    // ... other validation methods
}
```

### ‚öôÔ∏è Registration mechanism

Workflow components are **automatically discovered** via Spring's dependency injection system using the `OperationFactory`.

Here's how it works:

1. **Processor Discovery**: All Spring beans implementing `CyodaProcessor` are automatically collected by the `OperationFactory`.

2. **Criterion Discovery**: All Spring beans implementing `CyodaCriterion` are automatically collected by the `OperationFactory`.

3. **Operation Matching**: When a gRPC event arrives, the `OperationFactory` finds the appropriate processor or criterion by:
   - Calling the `supports(OperationSpecification)` method on each component
   - Matching based on the operation name from workflow configuration (e.g., `action.name` or `condition.function.name`)
   - Caching successful matches for performance using `ConcurrentHashMap`

4. **Execution**: The matched component processes the request using its `process()` or `check()` method.

### Component Registration

To register a processor or criterion:

1. **Create a class** implementing `CyodaProcessor` or `CyodaCriterion`
2. **Add `@Component` annotation** for Spring discovery
3. **Implement the `supports()` method** to define when this component should be used
4. **Implement the processing method** (`process()` for processors, `check()` for criteria)

### `supports()` Method Implementation

The `supports()` method determines when a component should handle a specific operation. Implementation depends on your processing approach:

#### **For JsonNode-based Processing** (JSON payload handling):
```java
@Override
public boolean supports(OperationSpecification opSpec) {
    // Only check operation name - works with any entity type
    return "example_function_name".equals(opSpec.operationName());
}
```

#### **For Entity-based Processing** (using `toEntityWithMetadata()` or `extractEntityWithMetadata()`):
```java
@Override
public boolean supports(OperationSpecification opSpec) {
    // Check both operation name AND model compatibility
    return "example_function_name".equals(opSpec.operationName()) &&
           "Pet".equals(opSpec.modelKey().getName()) &&
           opSpec.modelKey().getVersion() >= 1;
}
```

> ‚úÖ **Rule**: If your component uses `toEntityWithMetadata(Class)` or `extractEntityWithMetadata(Class)`, you MUST check model name and version compatibility in `supports()`. If you only process JSON payloads, checking operation name is sufficient.

---

## üîÑ Serializer Architecture

The application uses a serializer architecture with fluent APIs:

### ProcessorSerializer (in `common/serializer/`)
- **Purpose**: Handles entity extraction and response building for processors
- **Key Methods**:
  - `withRequest(request)` - Start fluent processing chain
  - `extractEntityWithMetadata(request, Class<T>)` - Extract typed entities
  - `extractPayload(request)` - Extract raw JSON payload
  - `responseBuilder(request)` - Create response builders

### CriterionSerializer (in `common/serializer/`)
- **Purpose**: Handles entity extraction and response building for criteria
- **Key Methods**:
  - `withRequest(request)` - Start fluent evaluation chain
  - `evaluate(Function<JsonNode, EvaluationOutcome>)` - Evaluate JSON with outcomes
  - `evaluateEntity(Class<T>, Function<CriterionEntityEvaluationContext<T>, EvaluationOutcome>)` - Evaluate entities with metadata
  - `withReasonAttachment(ReasonAttachmentStrategy)` - Configure reason attachment
  - `withErrorHandler(BiFunction<Throwable, JsonNode, ErrorInfo>)` - Configure error handling

### ProcessingChain vs EntityProcessingChain
- **ProcessingChain**: JSON-based processing with `map(Function<JsonNode, JsonNode>)`
- **EntityProcessingChain**: Type-safe entity processing with `map(Function<T, T>)`
- **Transition**: Use `toEntityWithMetadata(Class<T>)` to switch from JSON to entity flow
- **Transition**: Use `toJsonFlow(Function<T, JsonNode>)` to switch from entity to JSON flow

### SerializerFactory
- **Purpose**: Provides access to different serializer implementations
- **Default**: Jackson-based serializers for JSON processing
- **Usage**: Injected into processors and criteria for consistent serialization

**Example Usage:**
```java
// Instead of hardcoded strings
return serializer.responseBuilder(request)
    .withError("PROCESSING_ERROR", "Processing failed")
    .build();

// Use the enum for type safety
return serializer.responseBuilder(request)
    .withError(StandardErrorCodes.PROCESSING_ERROR.getCode(), "Processing failed")
    .build();
```

---

# usage-rules.md

# Usage Rules

This file helps both developers and AI agents follow conventions in the Java Client Template project. This file can be updated via project-specific tooling and should be maintained alongside code changes.

<!-- entities-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for entities -->
## Entities

- Always implement `CyodaEntity` interface for domain entities
- Use `Config.ENTITY_VERSION` constant instead of hardcoded version strings
- Place entity classes in `application/entity/` directory for automatic discovery
- Implement `getModelKey()` to return `OperationSpecification.Entity` with proper ModelSpec
- Override `isValid()` method to provide entity-specific validation logic
- Use static `ENTITY_NAME` constant for consistent entity naming
- Entity `id` types vary by entity (e.g., Pet uses `Long`, Mail uses different types)
<!-- entities-end -->

<!-- processors-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for processors -->
## Processors (CyodaProcessor)

- Implement `CyodaProcessor` interface for workflow processing components
- Use `@Component` annotation for automatic Spring discovery
- Inject `SerializerFactory` in constructor and get specific serializer immediately
- Use `ProcessorSerializer.withRequest(request).toEntityWithMetadata(Class).map().complete()` pattern
- Implement `supports(OperationSpecification)` method for processor selection
- Processor names are matched via `supports()` method against workflow configuration
- Use fluent EntityProcessingChain API for type-safe entity processing
- Always handle exceptions properly - either log and handle or throw without logging, never both
<!-- processors-end -->

<!-- criteria-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for criteria -->
## Criteria (CyodaCriterion)

- Implement `CyodaCriterion` interface for workflow criteria checking
- Criteria MUST be pure functions - no side effects or payload modifications
- Use `CriterionSerializer.withRequest(request).evaluateEntity(Class, validator).complete()` pattern
- Implement `supports(OperationSpecification)` method for criteria selection
- Use `EvaluationOutcome.and()` chaining for validation logic
- Return boolean evaluation results only - no entity modifications
- Use `withReasonAttachment(ReasonAttachmentStrategy.toWarnings())` for validation feedback
<!-- criteria-end -->

<!-- serializers-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for serializers -->
## Serializers

- Use `SerializerFactory` to get appropriate serializer instances
- Prefer `ProcessorSerializer` for processors and `CriterionSerializer` for criteria
- Use fluent APIs: `withRequest().toEntityWithMetadata().map().complete()` for processors
- Use fluent APIs: `withRequest().evaluateEntity().complete()` for criteria
- Jackson serializers are the default implementation (`SerializerEnum.JACKSON`)
- Always validate requests before processing in serializer implementations
- Use `ResponseBuilder.forProcessor()` and `ResponseBuilder.forCriterion()` for responses
<!-- serializers-end -->

<!-- services-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for services -->
## Services

- Always interact with `EntityService` interface, not repository directly
- Use **synchronous** methods - no more `CompletableFuture` complexity
- Use **JPA-style** naming: `save()`, `findAll()`, `deleteById()`, etc.
- Work with **type-safe** `EntityResponse<T>` and `List<EntityResponse<T>>`
- Use **business ID methods** for convenience: `findByBusinessId()`, `updateByBusinessId()`
- Use **SearchConditionRequest** for type-safe search conditions (not Object)
- Include **transition parameter** in update operations when needed
- Extract business data with `response.getData()` from EntityResponse
- Use technical ID from `response.getId()` for update/delete operations
<!-- services-end -->

<!-- controllers-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for controllers -->
## Controllers

- Use `@RestController` and `@RequestMapping` for REST endpoints
- Inject `EntityService` and `ObjectMapper` via constructor
- Use `@Valid` annotation for request body validation
- Return appropriate HTTP status codes (400 for validation, 404 for not found, 500 for errors)
- Log errors with context information (entity ID, operation type)
- Use `ResponseEntity<T>` for proper HTTP response handling
- Extract business data from `EntityResponse<T>` using `response.getData()`
- Use `entityService.save()` instead of `create()` for JPA consistency
- Use `entityService.findByBusinessId()` for business ID lookups
- Handle `List<EntityResponse<T>>` by mapping to business entities when needed
<!-- controllers-end -->

<!-- workflow-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for workflow -->
## Workflow Configuration

- Place `Workflow.json` files alongside entity classes in `application/entity/` directory
- Use finite-state machine (FSM) model for workflow definitions
- Avoid cyclic FSM states in workflow configuration
- Component operation names must match `supports()` method implementations
- Use `WorkflowImportTool` for importing workflow configurations
- Workflow methods should be separate processor classes, not switch-based dispatch
<!-- workflow-end -->

<!-- config-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for config -->
## Configuration

- Use `Config` class constants instead of hardcoded values
- Load environment variables via `Dotenv` in Config class
- Use `Config.ENTITY_VERSION` for entity versioning (default '1')
- Configure GRPC settings via environment variables
- Use `Config.CYODA_HOST` and related constants for Cyoda integration
- SSL and authentication settings should be configurable via environment
<!-- config-end -->

<!-- testing-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for testing -->
## Testing

- Use `PrototypeApplicationTest` for test-based prototype development
- Enable prototype mode via `-Dprototype.enabled=true` system property
- Test serializers using fluent API patterns
- Mock `EntityService` and `SerializerFactory` in unit tests
- Mock `EntityResponse<T>` objects in tests with proper data and metadata
- Test with `SearchConditionRequest` objects for type-safe condition testing
- Use synchronous EntityService methods (no CompletableFuture handling needed)
- Test both success and error scenarios for processors and criteria
<!-- testing-end -->

<!-- architecture-start -->
<!-- SYNC_COMMENT: synchronize via project tooling for architecture -->
## Architecture Guidelines

- Follow separation of concerns: entities, processors, criteria, services, controllers
- Use dependency injection via Spring constructor injection
- Implement interfaces rather than concrete classes for better testability
- Use sealed classes for type-safe operation specifications
- Prefer composition over inheritance in workflow components
- Use factory patterns for component selection and instantiation
- Handle async operations with CompletableFuture consistently
<!-- architecture-end -->
