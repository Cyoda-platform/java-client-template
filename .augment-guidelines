# Augment Guidelines - Java Client Template

## Project Structure
This is a **Gradle project** using **Spring Boot** with **Cyoda integration**.

## Rules
You must follow the rules given in the @.augment/rules folder.
Some are applied at all times, others are applicable only under certain circumstances.
The file @.augment/rules/README.md will tell you what the scope for each rules .md file is.
Make sure you follow all the rules that are applicable to your current task.

## Package Management
Always use appropriate package managers for dependency management instead of manually editing package configuration files.

1. **Always use package managers** for installing, updating, or removing dependencies rather than directly editing files like package.json, requirements.txt, Cargo.toml, go.mod, etc.

2. **Exception**: Only edit package files directly when performing complex configuration changes that cannot be accomplished through package manager commands.

## EntityService Usage - CRITICAL PATTERNS

### ‚úÖ CORRECT EntityService Patterns
```java
// Use performance-optimized methods with clear guidance
EntityWithMetadata<Cart> myEntity = entityService.getById(uuid, Cart.class);
EntityWithMetadata<Cart> myEntity = entityService.findByBusinessId(Cart.class, "CART-123", "myEntityId");
List<EntityWithMetadata<MyOtherEntity>> myOtherEntitys = entityService.findAll(MyOtherEntity.class);
List<EntityWithMetadata<MyOtherEntity>> results = entityService.search(MyOtherEntity.class, condition);

// Always work with EntityWithMetadata<T> (uses Lombok @Data)
Cart myEntityEntity = response.getEntity();  // Lombok generates this getter
UUID technicalId = response.getMetadata().getId();
String state = response.getMetadata().getState();

// JSON Structure is clean and consistent
{
  "entity": { "myEntityId": "CART-123", "items": [...] },
  "metadata": { "id": "uuid", "state": "ACTIVE" }
}
```

### ‚úÖ CORRECT Unified Processor Interface
```java
// Unified EntityWithMetadata processing - work directly with EntityWithMetadata
return serializer.withRequest(request)
    .toEntityWithMetadata(EntityName.class)  // Unified with controllers
    .validate(this::isValidEntityWithMetadata, "Invalid entity wrapper")
    .map(this::processEntityWithMetadataLogic)
    .complete();
```

## Processor Implementation - CRITICAL PATTERNS

### ‚úÖ CORRECT Processor Patterns
```java
@Component
public class ProcessorName implements CyodaProcessor {
    private final ProcessorSerializer serializer;
    // Optional: Only inject EntityService if you need to interact with other entities
    private final EntityService entityService;

    // Constructor WITHOUT EntityService (for simple processors)
    public ProcessorName(SerializerFactory serializerFactory) {
        this.serializer = serializerFactory.getDefaultProcessorSerializer();
    }

    // Constructor WITH EntityService (only if needed)
    public ProcessorName(SerializerFactory serializerFactory, EntityService entityService) {
        this.serializer = serializerFactory.getDefaultProcessorSerializer();
        this.entityService = entityService;
    }

    private EntityWithMetadata<EntityName> processEntityWithMetadataLogic(ProcessorSerializer.ProcessorEntityResponseExecutionContext<EntityName> context) {
        EntityWithMetadata<EntityName> entityWithMetadata = context.entityResponse(); // ‚úÖ CORRECT - contains entity and metadata
        EntityName entity = entityWithMetadata.getEntity();

        // Get current entity metadata (CRITICAL: Cannot update current entity)
        UUID currentEntityId = context.request().getEntityId(); // Technical ID of current entity
        String currentState = (String) context.request().getPayload().getMeta().get("state"); // Current state

        // Use entity getters directly
        String value = entity.getSomeField();

        // If interacting with OTHER entities, use EntityService (‚úÖ ALLOWED)
        EntityWithMetadata<OtherEntity> otherResponse = entityService.getById(someId, OtherEntity.class); // FASTEST
        OtherEntity other = otherResponse.getEntity();
        UUID otherEntityId = otherResponse.getMetadata().getId(); // For updates

        // Update OTHER entity with transition (‚úÖ ALLOWED)
        EntityWithMetadata<OtherEntity> updated = entityService.update(otherEntityId, other, "TRANSITION_NAME");

        return entityWithMetadata; // CRITICAL: Cannot update current entity state
    }
}
```

### ‚ùå FORBIDDEN Processor Anti-Patterns
```java
// NEVER inject ObjectMapper in processors
public ProcessorName(SerializerFactory factory, ObjectMapper objectMapper) { ... } // ‚ùå FORBIDDEN

// NEVER extract from payload manually
Map<String, Object> payloadMap = objectMapper.convertValue(request.getPayload().getData(), Map.class); // ‚ùå FORBIDDEN

// NEVER reconstruct entities manually
EntityName entity = new EntityName();
entity.setField((String) payloadMap.get("field")); // ‚ùå FORBIDDEN

// NEVER try to update current entity state in processor
EntityWithMetadata<EntityName> updated = entityService.update(currentEntityId, entity, "TRANSITION"); // ‚ùå FORBIDDEN
```

### üö® CRITICAL Processor Limitations
```java
// ‚úÖ ALLOWED: Get current entity metadata
UUID currentEntityId = context.request().getEntityId();
String currentState = (String) context.request().getPayload().getMeta().get("state");

// ‚ùå FORBIDDEN: Update current entity (the one being processed)
// Processors can only READ current entity, not update it

// ‚úÖ ALLOWED: Update OTHER entities
EntityWithMetadata<OtherEntity> otherResponse = entityService.getById(otherId, OtherEntity.class);
EntityWithMetadata<OtherEntity> updated = entityService.update(otherId, otherEntity, "TRANSITION");

// ‚úÖ PERFORMANCE: Use technical UUIDs for EntityService calls
entityService.getById(technicalUuid, Class); // FASTEST

// ‚úÖ TRANSITIONS: Check workflow documentation for valid transitions
// ‚úÖ NO REFLECTION: Use entity getters/setters only
// ‚ùå CANNOT MODIFY: src/main/java/com/java_template/common directory
```

## Controller Implementation - CRITICAL PATTERNS

### ‚úÖ CORRECT Controller Patterns
```java
@RestController
@RequestMapping("/ui/entityname")
@CrossOrigin(origins = "*")
public class EntityNameController {
    private final EntityService entityService;

    public EntityNameController(EntityService entityService) {
        this.entityService = entityService;
    }

    @PostMapping
    public ResponseEntity<EntityWithMetadata<EntityName>> create(@RequestBody EntityName entity) {
        EntityWithMetadata<EntityName> response = entityService.save(entity); // ‚úÖ CORRECT
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{id}")
    public ResponseEntity<EntityWithMetadata<EntityName>> getById(@PathVariable UUID id) {
        EntityWithMetadata<EntityName> response = entityService.getById(id, EntityName.class);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/business/{businessId}")
    public ResponseEntity<EntityWithMetadata<EntityName>> getByBusinessId(@PathVariable String businessId) {
        EntityWithMetadata<EntityName> response = entityService.findByBusinessId(
            EntityName.class, businessId, "businessIdField");
        return response != null ? ResponseEntity.ok(response) : ResponseEntity.notFound().build();
    }
}
```

### ‚ùå FORBIDDEN Controller Anti-Patterns
```java
// NEVER accept Map<String, Object> as request body
@PostMapping
public ResponseEntity<Object> create(@RequestBody Map<String, Object> request) { ... } // ‚ùå FORBIDDEN

// NEVER return generic Object responses
public ResponseEntity<Object> someMethod() { ... } // ‚ùå FORBIDDEN

// NEVER manually extract entity data from Maps
String value = (String) request.get("field"); // ‚ùå FORBIDDEN
```